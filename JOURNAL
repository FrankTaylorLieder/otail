rlog - A Rust-based TUI log file viewer

This is a rebuild of jlog in rust... using TUI and hopefully much better
performance.

Choices:
  - TUI: https://github.com/ratatui/ratatui
    - Use the ELM architecture for the app:
      - Model, Update, View

- TUI example

Commit: 7e4ec61

- Core file reading
  - SFile - start to build out a searchable file.
  - Survey() - scans the file to create a set of line offsets. Currently this is a synchronous.

Commit: 570732b

- Async survey: (example)
  - Start to build out the command structure, enabling the IFile to receive new data, but the view to query existing data.

Commit: 723bd59

- Tailing files, detecting truncation
  - See: https://github.com/notify-rs/notify?tab=readme-ov-file
  - Example: tail.rs
  - As we are using this with Tokio, disable crossbeam-channel as per docs.

Commit: d3dab7c

- Detect if the final line is complete or not.

Commit: b3572fc

- Lay out the backend of rtail... drive using a fixed frontend.
  - IFile
    - Enable registered tailers. (NOT NEEDED?)
    - DONE Enable registered updaters.
  - DONE File Reader
  - Deal with:
    - DONE Truncation
    - DONE File deletion
  - Filtered file (FFile)
    - Like an IFile but uses an IFile as its source instead of a File Reader.
  - View (with colouring) on top of raw IFile or FFile
    - Or do we always have an FFile which sometimes as not filter... does not seem worth it.
    - Create a XFile trait to hide the details of file implementation, or connect with channels?
      - Use channels as FFile is active (scanning the underlying IFile to find matches).
    - DONE Create a test View which just outputs to stdout.
  - Running more than one file at a time

  Design:

  View -> IFile
    -> Get Line
    -> Register updater
    -> Enable/disable tailing
    <- File size change
    <- Truncated
    <- Tail line
    <- Error

  IFile -> Reader
    <- Line
    <- Truncated
    <- Error

  - TUI
    - tui.rs in examples
      - Build out a static version of the UI to play with concepts.
      - DONE: building a list backed by a large data structure
        - Currently the list requires that all items are rendered each frame... this will not work if the file is large.
        - DONE: Build a widget which only renders the items in the current view. E.g. LazyList.
      - DONE Make this event drive so it only updates the UI when something has happened.

Commit: c6a16cd

- Next: integrate the TUI into the main program.
  - Call the View directly from the TUI, or merge. Handle all events in the TUI, passing them to the View for processing.
  - Beef up the LazyList -> LazyTable - i.e. multi-column (to support FilterView match line numbers).
  - Tailing? Can we send a command to the TUI after updating the View to ensure we render the end of the View buffer.
  - View should only store lines that are currently visible.
    - Need to pass view size into handler.
  - IFile should not store data, just line indexes.
  - Colouring is done in the View.

Design:

  TUI -> View (Method)
    Get line
    Set line range (to drive caching)
    Change tail state
    
  View -> TUI (Command)
    Change selected line (last (tailing), first (truncated))
    Truncated (to drive something in the display)
    Error

  View -> IFile
    Register updater
    Request line

  View <- IFile
    Truncated
    Line
    Error
